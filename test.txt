To customize the keepAliveTimeout and headersTimeout values in an embedded Jetty server within a Spring Boot application, you'll need to modify the Jetty server's configuration. This involves creating a JettyServerCustomizer bean that adjusts the desired timeout settings on the server. Here's how you can do it:

Define a JettyServerCustomizer Bean: This customizer will allow you to access the underlying Jetty server and modify its configurations, including the timeouts for keep-alive and headers.

Adjust KeepAlive and Headers Timeout: Use the customizer to navigate through the server's connectors and adjust the idleTimeout (which influences the keep-alive timeout) and potentially the httpConfiguration for header timeouts.

https://howtodoinjava.com/spring-boot/configure-jetty-server/
https://www.dailycodebuffer.com/configure-jetty-server-in-spring-boot/
https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot/src/test/java/org/springframework/boot/web/embedded/jetty/JettyServletWebServerFactoryTests.java

Here's an example code snippet that demonstrates how to implement these changes:

import org.eclipse.jetty.server.*;
import org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JettyServerConfiguration {

    @Bean
    public WebServerFactoryCustomizer<JettyServletWebServerFactory> jettyServerCustomizer() {
        return factory -> factory.addServerCustomizers(server -> {
            for (Connector connector : server.getConnectors()) {
                if (connector instanceof ServerConnector) {
                    ServerConnector serverConnector = (ServerConnector) connector;
                    serverConnector.setIdleTimeout(10000); // KeepAliveTimeout in milliseconds
                    
                    HttpConnectionFactory httpConnectionFactory = serverConnector.getConnectionFactory(HttpConnectionFactory.class);
                    if (httpConnectionFactory != null) {
                        HttpConfiguration httpConfiguration = httpConnectionFactory.getHttpConfiguration();
                        if (httpConfiguration != null) {
                            httpConfiguration.setIdleTimeout(5000); // HeadersTimeout in milliseconds
                        }
                    }
                }
            }
        });
    }
}


In this code:

serverConnector.setIdleTimeout(10000); sets the keep-alive timeout. Replace 10000 with your desired timeout in milliseconds.
httpConfiguration.setIdleTimeout(5000); sets the headers timeout. Replace 5000 with your desired timeout in milliseconds.
This example customizes the Jetty server used by Spring Boot to have specific timeouts for keep-alive and headers. 



For Spring Boot applications using an embedded Jetty server, many common server properties can be directly configured in the application.yml (or application.properties) file without the need for custom code. However, as of my last update in April 2023, specific settings such as keepAliveTimeout and headersTimeout for the Jetty server are not directly exposed as configuration properties in Spring Boot's application configuration files.

Spring Boot provides a wide range of common server properties that can be configured directly in application.yml, like server port, SSL settings, and basic session timeout, but for more detailed configurations specific to Jetty, such as adjusting the keepAliveTimeout and headersTimeout, you typically need to implement a custom bean configuration.

The need to write a separate bean class for such customizations arises because these settings are specific to the underlying server's configuration details, which Spring Boot does not expose directly through its high-level properties. This approach allows for more flexibility and control over the server's behavior, enabling you to tailor the server to your application's specific needs.

If your goal is to avoid Java configuration and keep configuration within YAML files as much as possible, you might consider using Spring Boot's support for externalized configuration to inject these values into your custom bean. However, you would still need to implement a bean to apply these injected values to the Jetty server configuration because direct YAML configuration for these specific Jetty server properties is not supported out of the box.

For example, you could define properties in application.yml and use @Value annotations to inject them into your customizer bean, but the bean itself is necessary to apply these properties to the Jetty server. This method combines external configuration with the flexibility of programmatic server configuration adjustments.
