Handling Sensitive Data Masking in Spring Boot 3.x
When working with Spring Boot 2.x, masking sensitive properties like password, token, and secret in actuator endpoints (/actuator/env, /actuator/configprops) was pretty straightforward. Spring Boot handled this out of the box with the keys-to-sanitize property. You could just add keys to it, and they’d automatically get masked. But if you’ve upgraded to Spring Boot 3.x, you might have noticed that this behavior has changed, and relying solely on keys-to-sanitize might not work as expected—especially when dealing with nested or custom keys.

Why It Worked in Spring Boot 2.x
In Spring Boot 2.x, the actuator endpoints automatically masked sensitive values. By default, Spring Boot would sanitize any key containing terms like password, secret, or token, and if you had custom keys, you could simply add them to the keys-to-sanitize property.

For example:

properties
Copy code
management.endpoint.env.keys-to-sanitize=password,secret,key
This was easy to manage, and Spring Boot took care of masking the values for you, ensuring no sensitive information was leaked in your actuator endpoints.

What Changed in Spring Boot 3.x
Now with Spring Boot 3.x, things are a little different. While keys-to-sanitize still exists, its behavior is more nuanced. In some cases, especially with deeply nested or custom properties, it doesn't work as seamlessly as it did in 2.x.

A few key changes:

Default Masking: Sensitive values are masked by default in Spring Boot 3.x, and you can control the visibility of unsanitized values using the show-values property. So, if you're relying on always seeing unsanitized values for certain keys, you'll need to configure access for that.
Role-Based Access: By default, even if you configure show-values=ALWAYS, sensitive fields will still be sanitized unless you have a more explicit configuration.
Here's the config you'd typically use to allow unsanitized values:

properties
Copy code
management.endpoint.env.show-values=ALWAYS
management.endpoint.configprops.show-values=ALWAYS
This lets you view unsanitized values, but again, keys-to-sanitize might not handle all edge cases, especially if your keys are nested like oauth.token.value or have custom structures.

Why I Went With a Custom Approach
In my case, I needed to ensure specific keys like password, token, redisPassword, and adminSecret were always masked, no matter how deeply nested they were. Since management.endpoint.env.keys-to-sanitize wasn't masking these consistently, I opted to implement a custom sanitization approach using a SanitizingFunction.

Here's what the custom approach looks like:

java
Copy code
import org.springframework.boot.actuate.endpoint.SanitizableData;
import org.springframework.boot.actuate.endpoint.SanitizingFunction;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.regex.Pattern;

@Configuration
public class ActuatorSanitizerConfig {

    @Bean
    public SanitizingFunction customSanitizer() {
        // Regex to catch any key containing 'password', 'token', 'secret', etc.
        Pattern sensitivePattern = Pattern.compile(
                ".*(password|secret|token|redisPassword|adminSecret).*", 
                Pattern.CASE_INSENSITIVE
        );

        return (SanitizableData data) -> {
            if (sensitivePattern.matcher(data.getKey()).matches()) {
                return data.withValue("****");  // Mask the value with ****
            }
            return data;
        };
    }
}
This approach gives more flexibility and ensures that any key with terms like password, token, or secret is masked, no matter how complex or nested the key structure is. It’s also case-insensitive, so it works for ADMIN_SECRET, aws.credentials.load.type, or any variation you might have.

Wrapping It Up
In Spring Boot 2.x, you could rely on keys-to-sanitize to handle most of the sanitization automatically, but Spring Boot 3.x introduces more secure default behavior and greater control via role-based access. While the property still exists, it may not work for more complex configurations, and that's where a custom SanitizingFunction comes into play.

To summarize:

In Spring Boot 2.x, masking sensitive fields was automatic and simpler.
In Spring Boot 3.x, masking is handled by default, but if you need precise control, especially for nested properties, you'll likely need to customize it.
For complex scenarios like mine, a custom SanitizingFunction using regex patterns ensures no sensitive data is exposed, even with deeply nested keys.
This custom solution has worked well in ensuring that fields like password, token, and similar sensitive values remain masked, even when keys-to-sanitize wasn’t sufficient.

Hope this helps if you're running into similar issues with actuator endpoints in Spring Boot 3.x!
