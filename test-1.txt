Handling Sensitive Data Masking in Spring Boot 3.x
In Spring Boot 2.x, sensitive properties like passwords, secrets, and tokens were masked by default in actuator endpoints like /actuator/env and /actuator/configprops. You didn't have to do much — Spring Boot took care of masking common keys (like password) out of the box with the keys-to-sanitize property. If you wanted more keys masked, you’d just extend the list.

But with Spring Boot 3.x, things are a bit more controlled and secure. The keys-to-sanitize property still exists, but Spring Boot 3.x focuses more on role-based access to sensitive data, which means sensitive values are masked by default unless you allow them to be viewed.

Why Did It Work by Default in 2.x?
In Spring Boot 2.x, Spring’s actuator endpoints automatically masked sensitive properties such as password, secret, token, etc. This was managed using the keys-to-sanitize property, and Spring Boot automatically applied sensible defaults. Even if you didn’t set anything, keys matching certain patterns were always masked (****).

Example in 2.x:

properties
Copy code
management.endpoint.env.keys-to-sanitize=password,secret,key
What Changed in 3.x?
With Spring Boot 3.x, sanitization is more secure, and Spring gives you greater control over how sensitive data is exposed. Here’s what changed:

Default Masking: Now, all sensitive values are masked by default. If you want to see these unsanitized values, you need to configure role-based access.
Role-Based Control: You can control who gets to see unsanitized data using the show-values property. By default, sensitive values are always masked (NEVER), but you can change this to show unsanitized values to authorized users (WHEN_AUTHORIZED).
Example configuration:

properties
Copy code
management.endpoint.env.show-values=WHEN_AUTHORIZED
management.endpoint.configprops.show-values=WHEN_AUTHORIZED
This lets you specify that only authorized users (with certain roles) can view sensitive data, adding a layer of security.

How to Mask Specific Keys
If you have custom sensitive keys like redisPassword, adminSecret, or similar, you’ll still use keys-to-sanitize. The only difference is that you need to be more explicit about what you want to sanitize.

Example:

properties
Copy code
management.endpoint.env.keys-to-sanitize=password,secret,token,redisPassword,adminSecret
management.endpoint.configprops.keys-to-sanitize=password,secret,token,redisPassword,adminSecret
This will ensure any key containing these terms is masked.

Custom Sanitization (Optional)
For more complex scenarios where you have deeply nested or custom key structures (like aws.credentials.load.type), you can define a custom SanitizingFunction. This approach uses regex patterns to match keys and mask their values.

Example:

java
Copy code
import org.springframework.boot.actuate.endpoint.SanitizableData;
import org.springframework.boot.actuate.endpoint.SanitizingFunction;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ActuatorSanitizerConfig {

    @Bean
    public SanitizingFunction customSanitizer() {
        return (SanitizableData data) -> {
            // Mask any key with 'password', 'token', etc.
            if (data.getKey().matches(".*(password|secret|token|adminSecret).*")) {
                return data.withValue("****");
            }
            return data;
        };
    }
}
This function allows you to apply complex matching logic for nested properties.

Wrap-Up
In Spring Boot 2.x, masking happened automatically for keys like password, and you could add more keys with keys-to-sanitize.
In Spring Boot 3.x, all sensitive data is masked by default unless you allow unsanitized values through show-values=WHEN_AUTHORIZED.
You can still use keys-to-sanitize to mask custom keys, but if your key structure is complex, use a custom SanitizingFunction.
This gives you more control and security in how you expose sensitive data, which is especially important in production environments.
